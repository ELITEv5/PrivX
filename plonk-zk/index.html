let web3, userAccount, selectedDenomination;
let poseidonHasher = null;

// Initialize standard Poseidon from local poseidon.js
(async () => {
  try {
    poseidonHasher = await buildPoseidon();
    console.log("âœ… Standard Poseidon hasher loaded and ready");
  } catch (err) {
    console.error("Poseidon load failed:", err);
    alert("Privacy library failed to load. Check poseidon.js file.");
  }
})();

const PRIVX_TOKEN = "0x34310B5d3a8d1e5f8e4A40dcf38E48d90170E986";
const SHIELD_CONTRACTS = {
  "100": "0x38bF8a5aA873331c0c92AA3a42182545660fd279",
  "1000": "0xfe742B76D0223f74d046729520931AD9E1A502e4",
  "10000": "0x4053759d1576D6C2D479E2109c9678587b888412",
  "100000": "0xB2050e90F9b2979A7a5B391c6e4dE1fAcCd3A898"
};
const DENOM_AMOUNTS = {
  "100": "100000000000000000000",
  "1000": "1000000000000000000000",
  "10000": "10000000000000000000000",
  "100000": "100000000000000000000000"
};
const WASM_URL = "./circuits/mixer_js/mixer.wasm";
const ZKEY_URL = "https://amaranth-rear-platypus-218.mypinata.cloud/ipfs/bafybeiedimujorboc74sqeae3uzvi4ybixcz3bd2hds4smlnjwrxgwbzt4";

const ERC20_ABI = [
  {
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "approve",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "owner", "type": "address" },
      { "internalType": "address", "name": "spender", "type": "address" }
    ],
    "name": "allowance",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  }
];
const SHIELD_ABI = [
  { "inputs": [{ "internalType": "bytes32", "name": "_commitment", "type": "bytes32" }],
    "name": "deposit", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [
      { "internalType": "bytes", "name": "_proof", "type": "bytes" },
      { "internalType": "uint256[3]", "name": "_pubSignals", "type": "uint256[3]" },
      { "internalType": "address payable", "name": "recipient", "type": "address" }
    ],
    "name": "withdraw",
    "outputs": [], "stateMutability": "nonpayable", "type": "function"
  },
  { "inputs": [], "name": "getLastRoot", "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }], "stateMutability": "view", "type": "function" },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "bytes32", "name": "commitment", "type": "bytes32" },
      { "indexed": false, "internalType": "uint32", "name": "leafIndex", "type": "uint32" },
      { "indexed": false, "internalType": "uint256", "name": "timestamp", "type": "uint256" }
    ],
    "name": "Deposit",
    "type": "event"
  }
];

function switchTab(tab) {
  document.getElementById('depositTab').classList.toggle('hidden', tab !== 'deposit');
  document.getElementById('withdrawTab').classList.toggle('hidden', tab !== 'withdraw');
  document.getElementById('depositTabBtn').classList.toggle('active', tab === 'deposit');
  document.getElementById('withdrawTabBtn').classList.toggle('active', tab === 'withdraw');
}

async function deposit() {
  if (!poseidonHasher) {
    alert("Privacy system loading... please wait.");
    return;
  }
  if (!userAccount || !selectedDenomination) return alert("Connect wallet & select amount");
  const btn = document.getElementById("depositBtn");
  btn.disabled = true;
  btn.textContent = "Generating Note...";
  try {
    function generateRandomBytes(length = 32) {
      const bytes = crypto.getRandomValues(new Uint8Array(length));
      const extra = new TextEncoder().encode(userAccount + Date.now().toString());
      for (let i = 0; i < extra.length; i++) {
        bytes[i % length] ^= extra[i];
      }
      return bytes;
    }
    const nullifier = generateRandomBytes(32);
    const secret = generateRandomBytes(32);
    const nullifierHex = [...nullifier].map(b => b.toString(16).padStart(2, "0")).join("");
    const secretHex = [...secret].map(b => b.toString(16).padStart(2, "0")).join("");
    const nullifierBI = BigInt("0x" + nullifierHex);
    const secretBI = BigInt("0x" + secretHex);
    const commitmentBI = (await poseidonHasher([nullifierBI, secretBI]))[0];
    const commitment = "0x" + commitmentBI.toString(16).padStart(64, "0");
    const note = `privx-hurricane-${selectedDenomination}-${nullifierHex}-${secretHex}`;
    document.getElementById("noteText").textContent = note;
    document.getElementById("depositNote").classList.remove("hidden");
    const amount = BigInt(DENOM_AMOUNTS[selectedDenomination]);
    const fee = (amount * 3n) / 1000n;
    const totalAmount = (amount + fee).toString();
    const shieldAddr = SHIELD_CONTRACTS[selectedDenomination];
    const privx = new web3.eth.Contract(ERC20_ABI, PRIVX_TOKEN);
    const shield = new web3.eth.Contract(SHIELD_ABI, shieldAddr);
    const allowance = await privx.methods.allowance(userAccount, shieldAddr).call();
    if (BigInt(allowance) < BigInt(totalAmount)) {
      btn.textContent = "Approving PRIVX + Fee...";
      await privx.methods.approve(shieldAddr, totalAmount).send({ from: userAccount });
    }
    btn.textContent = "Depositing...";
    const tx = await shield.methods.deposit(commitment).send({ from: userAccount });
    alert(`âœ… DEPOSIT SUCCESS!\nTX: ${tx.transactionHash}\n\nðŸ’¾ SAVE YOUR NOTE SECURELY!`);
  } catch (err) {
    console.error("Deposit error:", err);
    alert("Deposit failed: " + (err.message || "Check MetaMask or PRIVX balance"));
  } finally {
    btn.disabled = false;
    btn.textContent = `Shield ${selectedDenomination} PRIVX`;
  }
}

async function toggleWallet() {
  if (!window.ethereum) return alert("Install MetaMask");
  try {
    await window.ethereum.request({ method: "eth_requestAccounts" });
    try {
      await window.ethereum.request({ method: "wallet_switchEthereumChain", params: [{ chainId: "0x171" }] });
    } catch (e) {
      if (e.code === 4902) {
        await window.ethereum.request({
          method: "wallet_addEthereumChain",
          params: [{
            chainId: "0x171",
            chainName: "PulseChain",
            rpcUrls: ["https://rpc.pulsechain.com"],
            nativeCurrency: { name: "PLS", symbol: "PLS", decimals: 18 },
            blockExplorerUrls: ["https://scan.pulsechain.com"]
          }]
        });
      }
    }
    web3 = new Web3(window.ethereum);
    const accounts = await web3.eth.getAccounts();
    userAccount = accounts[0];
    document.getElementById("walletButtonText").textContent = `${userAccount.slice(0, 6)}...${userAccount.slice(-4)}`;
    document.getElementById("walletButton").classList.add("connected");
    updateDepositButton();
  } catch (err) {
    alert("Connection failed");
  }
};

if (window.ethereum) {
  window.ethereum.request({ method: "eth_accounts" }).then(a => a.length > 0 && toggleWallet());
}

function selectDenomination(denom) {
  selectedDenomination = denom;
  document.querySelectorAll('.denomination-card').forEach(c => c.classList.remove('selected'));
  event.target.closest('.denomination-card').classList.add('selected');
  updateDepositButton();
}

function updateDepositButton() {
  const btn = document.getElementById('depositBtn');
  if (!userAccount) {
    btn.textContent = "Connect Wallet First";
    btn.disabled = true;
  } else if (!selectedDenomination) {
    btn.textContent = "Select Denomination";
    btn.disabled = true;
  } else {
    btn.textContent = `Shield ${selectedDenomination} PRIVX`;
    btn.disabled = false;
  }
}

function copyNote() {
  navigator.clipboard.writeText(document.getElementById('noteText').textContent);
  alert("Note copied!");
}

async function updateBurnedBalance() {
  const el = document.getElementById("burnedBalance");
  if (!el) return;
  if (!web3) {
    el.textContent = "Connect wallet";
    return;
  }
  el.textContent = "Loading...";
  try {
    const token = new web3.eth.Contract([
      { "name": "balanceOf", "inputs": [{ "name": "account", "type": "address" }], "outputs": [{ "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }
    ], PRIVX_TOKEN);
    const [dead, fire] = await Promise.all([
      token.methods.balanceOf("0x000000000000000000000000000000000000dEaD").call(),
      token.methods.balanceOf("0x0000000000000000000000000000000000000369").call()
    ]);
    const totalBurned = BigInt(dead) + BigInt(fire);
    const burnedNum = Number(totalBurned / 10n ** 18n);
    el.innerHTML = `<strong>${burnedNum.toLocaleString()}</strong> PRIVX burned`;
  } catch (err) {
    console.error("Burn tracker error:", err);
    el.textContent = "Error";
  }
}

console.log("Testing hash direction alignment...");
// Test with standard Poseidon
(async () => {
  if (poseidonHasher) {
    const testLeft = (await poseidonHasher([0n, 1n]))[0];
    const testRight = (await poseidonHasher([1n, 0n]))[0];
    console.log("Poseidon(0,1) =", "0x" + testLeft.toString(16).padStart(64, "0"));
    console.log("Poseidon(1,0) =", "0x" + testRight.toString(16).padStart(64, "0"));
  }
})();

// Async buildTree with standard Poseidon
async function buildTree(leaves) {
  if (!poseidonHasher) throw new Error("Poseidon not loaded");
  const LEVELS = 20;
  const filledSubtrees = new Array(LEVELS);
  const zeros = [];
  let currentZero = 0n;
  for (let i = 0; i < LEVELS; i++) {
    zeros[i] = currentZero;
    filledSubtrees[i] = currentZero;
    currentZero = (await poseidonHasher([currentZero, currentZero]))[0];
  }
  let currentRoot = zeros[LEVELS - 1];
  for (let leafIndex = 0; leafIndex < leaves.length; leafIndex++) {
    let node = leaves[leafIndex];
    let index = leafIndex;
    for (let i = 0; i < LEVELS; i++) {
      if (index % 2 === 0) {
        node = (await poseidonHasher([zeros[i], node]))[0];
      } else {
        node = (await poseidonHasher([filledSubtrees[i], node]))[0];
      }
      filledSubtrees[i] = node;
      index = Math.floor(index / 2);
    }
    currentRoot = node;
  }
  return { root: currentRoot, filledSubtrees, zeros };
}

// Async getMerkleProof with standard Poseidon
async function getMerkleProof(shieldContract, targetCommitment) {
  if (!poseidonHasher) throw new Error("Poseidon not loaded");
  console.log("ðŸ” Building Merkle proof for commitment:", "0x" + targetCommitment.toString(16).padStart(64, "0"));

  const events = await shieldContract.getPastEvents("Deposit", { fromBlock: 0, toBlock: "latest" });
  if (events.length === 0) throw new Error("No deposits found");

  events.sort((a, b) => Number(a.returnValues.leafIndex) - Number(b.returnValues.leafIndex));
  const leaves = events.map(e => BigInt(e.returnValues.commitment));
  const leafIndex = events.findIndex(e => BigInt(e.returnValues.commitment) === targetCommitment);
  if (leafIndex === -1) throw new Error("Commitment not found");

  const { root: simulatedRoot, filledSubtrees, zeros } = await buildTree(leaves);

  const siblings = [];
  const pathIndices = [];
  let currentHash = leaves[leafIndex];
  let index = leafIndex;

  for (let level = 0; level < 20; level++) {
    const isLeft = index % 2 === 0;
    const siblingIndex = isLeft ? index + 1 : index - 1;
    const sibling = siblingIndex < leaves.length ? leaves[siblingIndex] : zeros[level];

    siblings.push("0x" + sibling.toString(16).padStart(64, "0"));
    pathIndices.push(isLeft ? 0 : 1);

    if (isLeft) {
      currentHash = (await poseidonHasher([zeros[level], currentHash]))[0];
    } else {
      currentHash = (await poseidonHasher([filledSubtrees[level], currentHash]))[0];
    }

    index = Math.floor(index / 2);
  }

  const reconstructedRoot = "0x" + currentHash.toString(16).padStart(64, "0");
  const onChainRoot = await shieldContract.methods.getLastRoot().call();

  console.log("ðŸ§© Recomputed proof root:", reconstructedRoot);
  console.log("ðŸŒ On-chain root:", onChainRoot);
  console.log("âœ… Match?", reconstructedRoot.toLowerCase() === onChainRoot.toLowerCase());

  if (reconstructedRoot.toLowerCase() !== onChainRoot.toLowerCase()) {
    throw new Error("Merkle root mismatch â€“ proof will fail.");
  }

  return { pathIndices, siblings, proofRoot: currentHash };
}

async function withdraw() {
  if (!poseidonHasher) {
    alert("Privacy system loading... please wait.");
    return;
  }
  const noteInput = document.getElementById("withdrawNote").value.trim();
  if (!noteInput) return alert("Paste your private note first");
  if (!userAccount || !web3) return alert("Connect wallet first");

  const match = noteInput.match(/^privx-hurricane-(\d+)-([a-fA-F0-9]{64})-([a-fA-F0-9]{64})$/);
  if (!match) return alert("Invalid note format");
  const [_, denomStr, nullifierHex, secretHex] = match;

  const denomination = BigInt(denomStr);
  const nullifier = BigInt("0x" + nullifierHex);
  const secret = BigInt("0x" + secretHex);

  const commitmentBI = (await poseidonHasher([nullifier, secret]))[0];
  const commitment = commitmentBI;

  const nullifierHashBI = (await poseidonHasher([nullifier, denomination, 0n]))[0];

  const shieldAddr = SHIELD_CONTRACTS[denomStr];
  if (!shieldAddr) return alert("Unsupported denomination");
  const shield = new web3.eth.Contract(SHIELD_ABI, shieldAddr);

  let root;
  try {
    root = await shield.methods.getLastRoot().call();
    console.log("On-chain root:", root);
  } catch {
    return alert("Failed to fetch Merkle root");
  }

  let pathIndices, siblings;
  try {
    const proofData = await getMerkleProof(shield, commitment);
    pathIndices = proofData.pathIndices;
    siblings = proofData.siblings;
    console.log("Path indices:", pathIndices);
    console.log("Siblings:", siblings.map(s => "0x" + BigInt(s).toString(16).padStart(64, "0")));
  } catch (e) {
    return alert(e.message);
  }

  const input = {
    nullifier: nullifier.toString(),
    secret: secret.toString(),
    pathIndices: pathIndices,
    siblings: siblings,
    root: "0x" + proofData.proofRoot.toString(16).padStart(64, "0"),
    denomination: denomination.toString(),
    nullifierHash: nullifierHashBI.toString()
  };

  const btn = document.getElementById("withdrawBtn");
  btn.disabled = true;
  btn.textContent = "Generating PLONK Proof... (30â€“90s, please wait)";

  try {
    const { proof, publicSignals } = await snarkjs.plonk.fullProve(input, WASM_URL, ZKEY_URL);

    const calldata = await snarkjs.plonk.exportSolidityCallData(proof, publicSignals);
    const argv = calldata.replace(/["[\]\s]/g, "").split(",").map(x => x.trim()).filter(x => x !== "");

    const proofArray = argv.slice(0, 24);
    const pubSignalsUint256 = argv.slice(24, 27);

    console.log("Proof array (24 uint256):", proofArray);
    console.log("Public signals [root, nullifierHash, denomination]:", pubSignalsUint256);

    const recipient = document.getElementById("recipientAddress").value.trim() || userAccount;

    const tx = await shield.methods.withdraw(proofArray, pubSignalsUint256, recipient).send({ from: userAccount });

    alert(`ðŸŽ‰ Withdrawal successful!\nTX: ${tx.transactionHash}\nFunds + reward sent to ${recipient}`);
  } catch (err) {
    console.error("Withdraw failed:", err);
    alert("Withdrawal failed: " + (err.message || "Check console for details"));
  } finally {
    btn.disabled = false;
    btn.textContent = "Generate Proof + Withdraw";
  }
}

window.addEventListener('load', () => {
  document.getElementById("walletButton").onclick = toggleWallet;
  document.getElementById('depositBtn').onclick = deposit;
  document.getElementById('withdrawBtn').onclick = withdraw;
  document.getElementById('depositTabBtn').addEventListener('click', () => switchTab('deposit'));
  document.getElementById('withdrawTabBtn').addEventListener('click', () => switchTab('withdraw'));
  switchTab('deposit');
  updateDepositButton();
  updateBurnedBalance();
  setInterval(updateBurnedBalance, 30000);
});
  </script>

  <!-- Matrix Rain -->
  <script>
    const canvas = document.getElementById('matrix-bg');
    const ctx = canvas.getContext('2d');
    canvas.width = innerWidth; canvas.height = innerHeight;
    let fontSize = innerWidth < 600 ? 10 : 14;
    const chars = '01PRIVXHURRICANE';
    let columns = Math.floor(canvas.width / fontSize);
    let drops = Array(columns).fill(1);
    function draw() {
      ctx.fillStyle = 'rgba(0,0,0,0.05)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#8A2BE2';
      ctx.font = fontSize + 'px monospace';
      drops.forEach((y,i) => {
        const text = chars[Math.floor(Math.random()*chars.length)];
        ctx.fillText(text, i*fontSize, y*fontSize);
        if(y*fontSize > canvas.height && Math.random() > 0.975) drops[i] = 0;
        drops[i]++;
      });
    }
    function loop(){ draw(); requestAnimationFrame(loop); }
    loop();
    addEventListener('resize', () => {
      canvas.width = innerWidth; canvas.height = innerHeight;
      fontSize = innerWidth < 600 ? 10 : 14;
      columns = Math.floor(canvas.width / fontSize);
      drops = Array(columns).fill(1);
    });
  </script>
</body>
</html>
